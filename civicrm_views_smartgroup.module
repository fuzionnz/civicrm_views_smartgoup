<?php

/**
 * Implement hook_views_data_alter().
 */
function civicrm_views_smartgroup_views_data_alter(&$data) {
  // Use civicrm_group_contact_union table instead as intermediate join table.
  // This table is an inferior materialized view (using triggers) that merges the
  // group contacts and smartgroup cache tables.
  $data['_civicrm_group_contact_union'] = $data['civicrm_group_contact'];
  $data['civicrm_group']['table']['join']['civicrm_contact']['left_table'] = '_civicrm_group_contact_union';
  $data['_civicrm_group_contact_union']['status']['filter']['handler'] = 'civicrm_views_smartgroup_filter_status';
  $data['_civicrm_group_contact_union']['status']['field']['handler'] = 'views_handler_field';
  unset($data['civicrm_group_contact']);

  // Trigger a smartgroup cache rebuild if we detect the view is being filtered by group_id.
  $data['civicrm_group']['id']['filter']['handler'] = 'civicrm_views_smartgroup_filter_numeric';
  $data['civicrm_group']['id']['argument']['handler'] = 'civicrm_views_smartgroup_argument_numeric';
  $data['civicrm_group']['title']['filter']['handler'] = 'civicrm_views_smartgroup_filter_pseudo_constant';
}

/**
 * Implements hook_views_query_alter().
 */
function civicrm_views_smartgroup_views_query_alter(&$view, &$query) {
  // Worst case: the group_contact_cache table is empty in a query that is potentially making use
  // of it. We rebuild the entire table which can be very slow.
  // This runs *after* the handlers, so this should only be triggered on views
  // with empty group ID filters or handlers.
  if (array_key_exists('_civicrm_group_contact_union', $query->table_queue)) {
    civicrm_initialize();
    if (!CRM_Core_DAO::singleValueQuery("SELECT COUNT(id) FROM civicrm_group_contact_cache")) {
      civicrm_api3('Job', 'group_rebuild', array());
    }
  }
}

/**
 * Implements hook_cron().
 */
function civicrm_views_smartgroup_cron() {
  civicrm_initialize();
  CRM_Contact_BAO_GroupContactCache::loadAll();
  _civicrm_views_smartgroup_ensure_table();
}

/**
 * Ensure our inferior materialized view is set up correctly.
 * Resync table data and reapply all triggers.
 */
function _civicrm_views_smartgroup_ensure_table() {
  civicrm_initialize();

  CRM_Core_DAO::executeQuery("TRUNCATE _civicrm_group_contact_union");
  CRM_Core_DAO::executeQuery("INSERT INTO _civicrm_group_contact_union
            SELECT
              `civicrm_group_contact`.`group_id` AS `group_id`,
              `civicrm_group_contact`.`contact_id` AS `contact_id`,
              `civicrm_group_contact`.`status` AS `status`
            FROM civicrm_group_contact
            UNION
            SELECT `civicrm_group_contact_cache`.`group_id` AS `group_id`,
                  `civicrm_group_contact_cache`.`contact_id` AS `contact_id`,
                  'Smartgroup' AS `status`
            FROM civicrm_group_contact_cache
            ON DUPLICATE KEY UPDATE `status` = VALUES(status)");

  CRM_Core_DAO::executeQuery("DROP TRIGGER IF EXISTS civicrm_group_contact_after_insert");
  CRM_Core_DAO::executeQuery("CREATE TRIGGER civicrm_group_contact_after_insert AFTER INSERT ON civicrm_group_contact
                              FOR EACH ROW
                              INSERT INTO _civicrm_group_contact_union (group_id, contact_id, status)
                              VALUES (NEW.group_id, NEW.contact_id, NEW.status)
                              ON DUPLICATE KEY UPDATE `status` = VALUES(status)");

  CRM_Core_DAO::executeQuery("DROP TRIGGER IF EXISTS civicrm_group_contact_after_update");
  CRM_Core_DAO::executeQuery("CREATE TRIGGER civicrm_group_contact_after_update AFTER UPDATE ON civicrm_group_contact
                              FOR EACH ROW
                              INSERT INTO _civicrm_group_contact_union (group_id, contact_id, status)
                              VALUES (NEW.group_id, NEW.contact_id, NEW.status)
                              ON DUPLICATE KEY UPDATE `status` = VALUES(status)");

  CRM_Core_DAO::executeQuery("DROP TRIGGER IF EXISTS civicrm_group_contact_after_delete");
  CRM_Core_DAO::executeQuery("CREATE TRIGGER civicrm_group_contact_after_delete AFTER DELETE ON civicrm_group_contact
                              FOR EACH ROW
                              DELETE FROM _civicrm_group_contact_union
                              WHERE group_id = OLD.group_id AND contact_id = OLD.contact_id");

  CRM_Core_DAO::executeQuery("DROP TRIGGER IF EXISTS civicrm_group_contact_cache_after_insert");
  CRM_Core_DAO::executeQuery("CREATE TRIGGER civicrm_group_contact_cache_after_insert AFTER INSERT ON civicrm_group_contact_cache
                              FOR EACH ROW
                              INSERT INTO _civicrm_group_contact_union (group_id, contact_id, status)
                              VALUES (NEW.group_id, NEW.contact_id, 'Smartgroup')
                              ON DUPLICATE KEY UPDATE `status` = VALUES(status)");

  CRM_Core_DAO::executeQuery("DROP TRIGGER IF EXISTS civicrm_group_contact_cache_after_update");
  CRM_Core_DAO::executeQuery("CREATE TRIGGER civicrm_group_contact_cache_after_update AFTER UPDATE ON civicrm_group_contact_cache
                              FOR EACH ROW
                              INSERT INTO _civicrm_group_contact_union (group_id, contact_id, status)
                              VALUES (NEW.group_id, NEW.contact_id, 'Smartgroup')
                              ON DUPLICATE KEY UPDATE `status` = VALUES(status)");

  CRM_Core_DAO::executeQuery("DROP TRIGGER IF EXISTS civicrm_group_contact_cache_after_delete");
  CRM_Core_DAO::executeQuery("CREATE TRIGGER civicrm_group_contact_cache_after_delete AFTER DELETE ON civicrm_group_contact_cache
                              FOR EACH ROW
                              DELETE FROM _civicrm_group_contact_union
                              WHERE group_id = OLD.group_id AND contact_id = OLD.contact_id");
}
